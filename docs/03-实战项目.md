# ç¬¬ä¸‰é˜¶æ®µï¼šå®æˆ˜é¡¹ç›® - Todo å…¨æ ˆåº”ç”¨

---

## ğŸ“˜ Part 1: è‡ªå®šä¹‰ Hook

### 1.1 ä¸ºä»€ä¹ˆè¦è‡ªå®šä¹‰ Hookï¼Ÿ

è‡ªå®šä¹‰ Hook å¯ä»¥å°†ç»„ä»¶ä¸­çš„çŠ¶æ€é€»è¾‘æå–å‡ºæ¥ï¼Œå®ç°ï¼š
- **é€»è¾‘å¤ç”¨**ï¼šå¤šä¸ªç»„ä»¶å…±äº«ç›¸åŒé€»è¾‘
- **å…³æ³¨ç‚¹åˆ†ç¦»**ï¼šUI å’Œä¸šåŠ¡é€»è¾‘åˆ†å¼€
- **æ›´å¥½çš„æµ‹è¯•æ€§**ï¼šå¯ä»¥å•ç‹¬æµ‹è¯• Hook

### 1.2 useTodos Hook

```tsx
// hooks/useTodos.ts
import { useState, useEffect, useCallback } from 'react';
import { todoApi, Todo } from '../services/api';

export function useTodos() {
  const [todos, setTodos] = useState<Todo[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  // åŠ è½½æ‰€æœ‰ Todo
  const loadTodos = useCallback(async () => {
    try {
      setLoading(true);
      setError(null);
      const data = await todoApi.getAll();
      setTodos(data);
    } catch {
      setError('åŠ è½½å¤±è´¥');
    } finally {
      setLoading(false);
    }
  }, []);

  // åˆå§‹åŒ–åŠ è½½
  useEffect(() => {
    loadTodos();
  }, [loadTodos]);

  // æ·»åŠ 
  const addTodo = useCallback(async (title: string) => {
    const newTodo = await todoApi.create({ title });
    setTodos(prev => [newTodo, ...prev]);
  }, []);

  // åˆ‡æ¢çŠ¶æ€
  const toggleTodo = useCallback(async (id: number) => {
    const updated = await todoApi.toggle(id);
    setTodos(prev => prev.map(t => t.id === id ? updated : t));
  }, []);

  // åˆ é™¤
  const deleteTodo = useCallback(async (id: number) => {
    await todoApi.delete(id);
    setTodos(prev => prev.filter(t => t.id !== id));
  }, []);

  return { todos, loading, error, addTodo, toggleTodo, deleteTodo, reload: loadTodos };
}
```

---

## ğŸ“— Part 2: ç­›é€‰å’Œæœç´¢

### 2.1 useMemo æ€§èƒ½ä¼˜åŒ–

```tsx
import { useMemo } from 'react';

function TodoList() {
  const { todos } = useTodos();
  const [filter, setFilter] = useState<'all' | 'active' | 'completed'>('all');
  const [search, setSearch] = useState('');

  // ä½¿ç”¨ useMemo ç¼“å­˜ç­›é€‰ç»“æœï¼Œé¿å…æ¯æ¬¡æ¸²æŸ“éƒ½é‡æ–°è®¡ç®—
  const filteredTodos = useMemo(() => {
    return todos
      .filter(todo => {
        if (filter === 'active') return !todo.completed;
        if (filter === 'completed') return todo.completed;
        return true;
      })
      .filter(todo => 
        todo.title.toLowerCase().includes(search.toLowerCase())
      );
  }, [todos, filter, search]);

  return (
    <div>
      {/* æœç´¢æ¡† */}
      <input
        value={search}
        onChange={e => setSearch(e.target.value)}
        placeholder="æœç´¢ä»»åŠ¡..."
      />
      
      {/* ç­›é€‰æŒ‰é’® */}
      <div>
        <button onClick={() => setFilter('all')}>å…¨éƒ¨</button>
        <button onClick={() => setFilter('active')}>è¿›è¡Œä¸­</button>
        <button onClick={() => setFilter('completed')}>å·²å®Œæˆ</button>
      </div>
      
      {/* åˆ—è¡¨ */}
      {filteredTodos.map(todo => (
        <TodoItem key={todo.id} todo={todo} />
      ))}
    </div>
  );
}
```

---

## ğŸ“™ Part 3: ç¼–è¾‘åŠŸèƒ½

### 3.1 å®ç°å†…è”ç¼–è¾‘

```tsx
function TodoItem({ todo, onUpdate, onDelete }) {
  const [editing, setEditing] = useState(false);
  const [editText, setEditText] = useState(todo.title);

  const handleSave = async () => {
    if (editText.trim()) {
      await onUpdate(todo.id, { title: editText.trim() });
      setEditing(false);
    }
  };

  const handleKeyPress = (e: React.KeyboardEvent) => {
    if (e.key === 'Enter') handleSave();
    if (e.key === 'Escape') {
      setEditText(todo.title);
      setEditing(false);
    }
  };

  if (editing) {
    return (
      <input
        value={editText}
        onChange={e => setEditText(e.target.value)}
        onBlur={handleSave}
        onKeyDown={handleKeyPress}
        autoFocus
      />
    );
  }

  return (
    <div onDoubleClick={() => setEditing(true)}>
      <span>{todo.title}</span>
      <button onClick={() => onDelete(todo.id)}>åˆ é™¤</button>
    </div>
  );
}
```

---

## ğŸ“• Part 4: ç»Ÿè®¡å’Œæ‰¹é‡æ“ä½œ

### 4.1 ç»Ÿè®¡ä¿¡æ¯

```tsx
const stats = useMemo(() => ({
  total: todos.length,
  completed: todos.filter(t => t.completed).length,
  active: todos.filter(t => !t.completed).length,
}), [todos]);
```

### 4.2 æ‰¹é‡æ“ä½œ

```tsx
// å…¨éƒ¨å®Œæˆ
const completeAll = async () => {
  await Promise.all(
    todos.filter(t => !t.completed).map(t => todoApi.toggle(t.id))
  );
  reload();
};

// æ¸…é™¤å·²å®Œæˆ
const clearCompleted = async () => {
  await Promise.all(
    todos.filter(t => t.completed).map(t => todoApi.delete(t.id))
  );
  reload();
};
```

---

## ğŸ¯ å®æˆ˜ä»»åŠ¡

æœ¬é˜¶æ®µå°†å®Œå–„ Todo åº”ç”¨ï¼Œå®ç°ï¼š
1. âœ… è‡ªå®šä¹‰ `useTodos` Hook
2. âœ… ç­›é€‰åŠŸèƒ½ï¼ˆå…¨éƒ¨/è¿›è¡Œä¸­/å·²å®Œæˆï¼‰
3. âœ… æœç´¢åŠŸèƒ½
4. âœ… åŒå‡»ç¼–è¾‘åŠŸèƒ½
5. âœ… ç»Ÿè®¡ä¿¡æ¯æ˜¾ç¤º
6. âœ… æ‰¹é‡æ“ä½œæŒ‰é’®
